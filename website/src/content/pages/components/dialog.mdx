---
id: dialog
title: Dialog
description: A modal window that appears on top of the main content.
---

<ComponentPreview id="Dialog" />

## Anatomy

To use the dialog component correctly, you'll need to understand its anatomy and how we name its parts.

> Each part includes a `data-part` attribute to help identify them in the DOM.

<Anatomy id="dialog" />

```tsx
<Dialog.Root>
  <Dialog.Trigger />
  <Dialog.Backdrop />
  <Dialog.Positioner>
    <Dialog.Content>
      <Dialog.Title />
      <Dialog.Description />
      <Dialog.CloseTrigger />
    </Dialog.Content>
  </Dialog.Positioner>
</Dialog.Root>
```

## Examples

Learn how to use the `Dialog` component in your project. Let's take a look at the most basic example

<Example id="basic" />

### Controlled

To create a controlled Dialog component, manage the state of the dialog using the `open` and `onOpenChange` props:

<Example id="controlled" />

### Open from Menu

To open a dialog from a menu item, control the dialog state and open it imperatively using the `onClick` handler on the
menu item:

<Example id="open-from-menu" />

### Lazy Mount

Lazy mounting is a feature that allows the content of a dialog to be rendered only when the dialog is first opened. This
is useful for performance optimization, especially when dialog content is large or complex. To enable lazy mounting, use
the `lazyMount` prop on the `Dialog.Root` component.

In addition, the `unmountOnExit` prop can be used in conjunction with `lazyMount` to unmount the dialog content when the
Dialog is closed, freeing up resources. The next time the dialog is activated, its content will be re-rendered.

<Example id="lazy-mount" />

### Alert Dialog

For critical confirmations or destructive actions, use `role="alertdialog"`. Alert dialogs differ from regular dialogs
in important ways:

- **Automatic focus**: The close/cancel button receives focus when opened, prioritizing the safest action
- **Requires explicit dismissal**: Cannot be closed by clicking outside, only via button clicks or Escape key

<Example id="alert-dialog" />

### Initial Focus

Control which element receives focus when the dialog opens using the `initialFocusEl` prop. This is useful for forms
where you want to focus a specific input field:

<Example id="initial-focus" />

### Final Focus

Control which element receives focus when the dialog closes using the `finalFocusEl` prop. By default, focus returns to
the trigger element, but you can specify a different element:

<Example id="final-focus" />

### Non-Modal

Use `modal={false}` to create a non-modal dialog that allows interaction with elements outside of it. This disables
focus trapping, scroll prevention, and pointer blocking, making it useful for auxiliary panels or inspector windows:

<Example id="non-modal" />

### Inside Scroll

When dialog content exceeds the viewport height, you can make the content area scrollable while keeping the header and
footer fixed. Set a `maxHeight` on the content and use `overflow: auto` on the scrollable section:

<Example id="inside-scroll" />

### Outside Scroll

Alternatively, make the entire positioner scrollable so the dialog can extend beyond the viewport. This approach works
well for long-form content where you want the dialog to feel more like a page:

<Example id="outside-scroll" />

### Context

Use the `Dialog.Context` component to access the dialog's state and methods.

<Example id="context" />

### Root Provider

The `useDialog` hook gives you programmatic access to the dialog's state and methods. Use it with `Dialog.RootProvider`
when you need to control the dialog from outside its component tree.

<Example id="root-provider" />

### Nested

You can nest dialogs within one another normally. When a nested dialog is open, the parent dialog receives a
`data-has-nested` attribute and a `--nested-layer-count` CSS variable indicating the number of nested layers.

Use these to customize the styling of the parent dialog, such as creating a zoom-out effect:

```css
.Content[data-has-nested] {
  transform: scale(calc(1 - var(--nested-layer-count) * 0.05));
}
```

Zag.js also provides a `--layer-index` CSS variable for z-index management. Use it to ensure proper stacking of dialog
layers:

```css
.Content {
  z-index: calc(var(--layer-index));
}
```

<Example id="nested" />

### Confirmation

Dialogs can intercept close attempts to show confirmation prompts. This pattern is useful for preventing data loss from
unsaved changes:

<Example id="confirmation" />

## Guides

### Close Behavior

Control how the dialog closes:

- `closeOnEscape={false}` - Prevent closing when pressing <kbd>Escape</kbd>
- `closeOnInteractOutside={false}` - Prevent closing when clicking outside

For conditional control, use `onEscapeKeyDown` or `onInteractOutside` with `e.preventDefault()`. See the Confirmation
example above for a practical implementation.

### Dynamic Imports

When using `lazyMount` and dynamically rendering components in the dialog (via `React.lazy`, Next.js `dynamic`), wrap
the imported component in a `Suspense` component to render a fallback.

```tsx
import { Dialog } from '@ark-ui/<framework>/dialog'
import { Suspense } from 'react'
import dynamic from 'next/dynamic'

const HeavyComponent = dynamic(() => import('./HeavyComponent'))

export default function DialogExample() {
  return (
    <Dialog.Root lazyMount>
      <Dialog.Trigger>Open Dialog</Dialog.Trigger>
      <Dialog.Content>
        <Suspense fallback={<div>Loading...</div>}>
          <HeavyComponent />
        </Suspense>
      </Dialog.Content>
    </Dialog.Root>
  )
}
```

## API Reference

### Props

<ComponentTypes id="dialog" />

### Context

These are the properties available when using `Dialog.Context`, `useDialogContext` hook or `useDialog` hook.

<ContextType id="dialog" />

## Accessibility

Complies with the [Dialog WAI-ARIA design pattern](https://www.w3.org/WAI/ARIA/apg/patterns/dialog-modal/).

### Keyboard Support

<KeyBindingsTable id="dialog" />
